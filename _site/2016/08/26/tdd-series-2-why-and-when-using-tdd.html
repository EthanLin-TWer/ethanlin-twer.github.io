<p>本文仅在Java上下文下讨论TDD。原因是Java具备适合TDD生存的一些语言特性：清晰的依赖引用import机制、完全的面向对象、不存在引用传递等。迁移讨论至其他语言上时请注意这些特性对TDD实践所带来的差异。</p>

<h2 id="背景银弹还是鸡肋">背景：银弹还是鸡肋</h2>

<p>TDD还是不TDD，这是在ThoughtWorks工作绕不过去的一个问题<del>怎么总觉得<a href="http://www.infoq.com/cn/articles/enterprise-systems-integration-points">这帽子扣得没熊节好</a><sup id="fnref:summarize"><a href="#fn:summarize" class="footnote">1</a></sup></del>。TDD是一种思维方式，它把测试带到了与开发同等的地位上来。如果想要让你的代码边界清晰，有序可控，自成模块文档，那么你必须写清晰易懂的测试，你必须知道单元测试如何覆盖产品代码。若果如其然，是不是每个ThoughtWorker都认同TDD，并自觉在项目上使用TDD？若并非每个人都做到，原因又是什么，是因为TDD确实也有它不适合的场景，或一言以蔽之，是因为人员TDD技巧与素养皆太菜？</p>

<p>第一个问题的答案是否定的。是不是每个ThoughtWorker都认同TDD这个我不清楚，因为我是认同的，而其他人我则懒于主动求证是否认同，故此命题无法证假；但后半句答案是否定的，至少我就不是，我自觉，但并非所有时刻都用；昨天和我聊TDD的澳洲ThoughtWorker阿蒙萌也是看情况用。我们2票便否定了“每个”这全称量词。那么，既然至少有2人在项目没有坚持使用TDD，（他们的）原因又是什么？阿蒙萌曰：</p>

<blockquote>
  <p>It depends.</p>
</blockquote>

<p>言下之意，TDD有时好用，有时难用。且就这个论断继续讨论下去，那么TDD什么场景下好用，什么场景下难用呢？那些难用的场景，是人员主观上技巧素养太弱而产生的误解呢，还是客观上真实存在的障碍呢？</p>

<h3 id="tdd适用场景">TDD适用场景</h3>

<ul>
  <li>输入输出非常清晰时（clear input/output）</li>
  <li>项目代码采用良好的MV*(MVP/MVC/MVVM)架构时（well MVP/MVC/MVVM designed）</li>
</ul>

<h3 id="tdd不适用场景">TDD不适用场景</h3>

<ul>
  <li>使用全局变量在方法间传递、保存值（shared global variable across methods in class）</li>
  <li>有副作用的方法（side-effect methods）</li>
  <li>无返回值的方法（void methods）</li>
  <li>逻辑层和视图层间耦合严重（logic deeply coupled with the view）</li>
</ul>

<h3 id="函数式的代码风格">函数式的代码风格</h3>

<p>适用第一点与不适用的第一二点其实是一个意思，即接近于<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">函数式编程</a>的代码风格：<strong>清晰的输入输出</strong>、<strong>无副作用</strong>、<strong>引用透明（Referential Transparency）</strong>。毕竟，没有输入输出，就没有测试用例。遵循测试驱动开发写出来的代码可能是这样的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span> 
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_give_80_percent_discount_when_customer_buying_over_3_apples</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
	<span class="kt">double</span> <span class="n">amount</span> <span class="o">=</span> <span class="n">customer</span><span class="o">.</span><span class="na">buy</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">apples</span><span class="o">.</span><span class="na">withEach</span><span class="err">$</span><span class="o">(</span><span class="mf">5.00</span><span class="o">));</span>
	
	<span class="n">assertThat</span><span class="o">(</span><span class="n">amount</span><span class="o">,</span> <span class="n">is</span><span class="o">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mf">5.00</span> <span class="o">*</span> <span class="mf">0.8</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="外部依赖">外部依赖</h3>

<p>不适用的第三点：没有返回值的方法。方法没有返回值，有以下几种可能的情况：</p>

<ul>
  <li>使用了全局变量，或修改或存储了应用的状态以供他用。这其实就是违反“函数式代码风格”的理念，见上讨论</li>
  <li>使用了输出参数。通常是在传入参数是个类型引用，然后在方法体内往传入参数中写值，从而达到方法返回值的效果</li>
  <li>调用了三方服务。比如进行了数据库操作、网络连接、文件读写等一切形式的I/O（非内存）操作</li>
</ul>

<p>首先我想表达的观点是，按照TDD进行的设计，很少会出现这种自己也测试不了的代码。但既然软件工程是人的行为，坏代码总会出现，那么以上面两点可能为例，这是无法解决的客观因素，还是可以解决的呢？可以解决。如果方法中使用了输出参数，那么可考虑是否将代码重构成正常的返回值方法；如果方法中调用了三方服务，那么测试策略可以从 <strong>验证返回值</strong> 的思路转换为 <strong>验证特定行为确实正确发生</strong>，这与第一篇技巧篇中提到的依赖注入技术和mock对象即可实现。</p>

<p>但不可否认，上面的“重构”这个字眼，意味着我们在TDD时，可能会有额外的投入，如额外添加测试保障、重构旧有代码等。这个问题，已不能从单纯技术层面进行解决，但后面我会聊。</p>

<h3 id="mv架构核心业务逻辑与模型视图的解耦">MV*架构——核心业务逻辑与模型/视图的解耦</h3>

<p>适用和不适用场景的最后一条，都提到了MV*架构对于TDD有所裨益。原因何在？因为有了清晰的分层，大部分主要的业务逻辑将由C（Controller，控制器）或VM（View Model）来负责。通过将领域模型和展示视图隔离出去，我们得以厘清业务层的输入输出。这回到了我们所聊到的第一点情况：函数式风格的输入输出。</p>

<p>不难发现，那些我们提到“TDD不一定适用”的场景，无论是因为代码上使用了难以测试的全局变量/输出参数，还是因为架构上业务逻辑与视图展示逻辑强耦合引起的测试黑洞，归根结底都指向了一个问题：取决于代码库设计/实现的好坏。好的代码容易TDD，自然维持更好；坏的代码TDD寸步难行，后来者更倾向于copy/paste重复代码，自然质量每况愈下。因此，看人品，如果你人品好，工作在优雅的codebase上，那就能TDD，否则就不能。</p>

<p>聊到这里似乎是把开发者的责任撇得干干净净：这是代码库的责任，而与开发者自身的TDD技艺、素养等无关。但我们不能止步于此，且不论好代码是如何得来，也暂且不论什么架构腐化演进的问题<del>因为我现在也聊不来…</del>，这里有一个问题Developer有责任思考及行动：<strong>重构（大型）遗留项目是否有价值？若是，如何对（大型）遗留项目进行重构？</strong></p>

<h2 id="大型遗留项目的重构与tdd">大型遗留项目的重构与TDD</h2>

<p>我们从TDD一路聊到大型遗留项目的重构，似乎是跑了题。这里为何强调大型？因为小型的重构和TDD可以在短时间（2~3天内的体量）完成，它们可以作为需求的一部分同时被交付，不涉及系统级的重构。一加大型，我们就需要意识到：其所需投入的时间和人力，已大至需要作为项目范围的一部分被规划和交付。那么，首要的问题即是，这样大型的系统重构，是否有意义？其价值何在？</p>

<h3 id="重构大型遗留项目的价值">重构大型遗留项目的价值</h3>

<p>要探讨价值，就要知道价值是什么，它需在一个系统和业务的上下文中展开。</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:summarize">
      <p>“集成是企业应用系统中绕不开的话题”。首句即把帽子扣下，这是绕不开的，所以我才来聊聊。真假不论，先装腔作势一番。 <a href="#fnref:summarize" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
