<p>为保护商业机密，本博客中出现的所有代码与文字均已隐去所有与客户相关的信息。若仍有泄露请第一时间联系博主我：linesh.simpcity@gmail.com。</p>

<h2 id="再次出发">再次出发</h2>

<p>在这个说开去系列的<a href="#/posts/2016-03-17-a-module-require-confusion">上篇</a>中，我们已经回答了项目自带的模块化的实现，同时也带出了更多的问题，总结起来有以下这些。它们是本篇视图回答的问题：</p>

<ul>
  <li><code class="highlighter-rouge">module.js</code>是如何被打包到<code class="highlighter-rouge">laodian-basic.js</code>中去？</li>
  <li>我们找到的这个js是在什么地方被include到页面上的？</li>
  <li>什么时候被include进来的？</li>
  <li>项目上用了什么方式来复用include这个js的那段代码？</li>
</ul>

<h3 id="如何打包">如何打包？</h3>
<p>上面我们还留下了一条线索：<code class="highlighter-rouge">laodian-basic.js</code>。既然<code class="highlighter-rouge">module.js</code>没有被引用的地方，那么就搜索下<code class="highlighter-rouge">laodian-basic.js</code>的引用点。这里我看到了两个引用点：</p>

<ol>
  <li><code class="highlighter-rouge">jawr.js.bundle.laodian.id=/bundles/laodian-basic.js</code></li>
  <li><code class="highlighter-rouge">&lt;laodian:script bundle="/bundles/laodian-basic.js" useVersionNumber="true" /&gt;</code></li>
</ol>

<p>看来似乎是配置了一些东西，然后直接在前端jsp(咦前端jsp怎么听起来怪怪的)通过<code class="highlighter-rouge">jsp tag</code>来引用。其中，第一个文件位于一个<code class="highlighter-rouge">jawr.properties</code>文件下，第二个文件的目录结构如下图所示。</p>

<p><img src="http://7xqu8w.com1.z0.glb.clouddn.com/a82b64e24b984d2a92c0c39397481825.png" alt="brand-specific-jsp-directory-structure" /></p>

<p>百年老店的项目有一个特点，就是支持多品牌，同一套代码需要服务不同地区的用户。我们挑了一个服务于大英地区的文件<code class="highlighter-rouge">british.jsp</code>，<code class="highlighter-rouge">Alt+F7</code>之，不能找到它的引用点。如我们第4点所要探索的问题所指出，由于要支持多品牌多页面，这个文件可能最终是通过这样的形式来被使用的：<code class="highlighter-rouge">&lt;%@ include file="${brand}.jsp" %&gt;</code>（手动反射）。这个目前还没有太多线索，那么先看看第一条线索，Google一下<a href="https://jawr.java.net/index.html">jawr</a>：它是一个可配置的、支持共用开发与发布代码的JS/CSS文件压缩与打包工具。配置简单：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jawr</span><span class="o">.</span><span class="na">js</span><span class="o">.</span><span class="na">budnle</span><span class="o">.</span><span class="na">laodian</span><span class="o">-</span><span class="n">basic</span><span class="o">.</span><span class="na">id</span><span class="o">=/</span><span class="n">bundle</span><span class="o">/</span><span class="n">laodian</span><span class="o">-</span><span class="n">basic</span><span class="o">.</span><span class="na">js</span>
<span class="n">jawr</span><span class="o">.</span><span class="na">js</span><span class="o">.</span><span class="na">budnle</span><span class="o">.</span><span class="na">laodian</span><span class="o">-</span><span class="n">basic</span><span class="o">.</span><span class="na">child</span><span class="o">.</span><span class="na">names</span><span class="o">=</span><span class="n">laodian</span><span class="o">-</span><span class="n">pages</span>
<span class="n">jawr</span><span class="o">.</span><span class="na">js</span><span class="o">.</span><span class="na">budnle</span><span class="o">.</span><span class="na">laodian</span><span class="o">-</span><span class="n">pages</span><span class="o">.</span><span class="na">mappings</span><span class="o">=/</span><span class="n">js</span><span class="o">/</span><span class="n">laodian</span><span class="o">-</span><span class="n">pages</span><span class="cm">/**/</span><span class="o">*.</span><span class="na">js</span>
</code></pre></div></div>

<p>看到上面这段代码就很清楚了，jawr会把<code class="highlighter-rouge">/js/laodian-pages/</code>文件夹下的所有js文件打包到<code class="highlighter-rouge">laodian-basic.js</code>文件中。JAWR其实还有一个<code class="highlighter-rouge">JawrServlet</code>，它会去读取<code class="highlighter-rouge">jawr.properties</code>(在<code class="highlighter-rouge">web.xml</code>文件的<code class="highlighter-rouge">init-param</code>配置<code class="highlighter-rouge">configLocation</code>)中的配置，并且拦截所有匹配<code class="highlighter-rouge">/js/*</code>的路径。</p>

<h3 id="js是如何被引用到页面上的sitemesh">js是如何被引用到页面上的？——SiteMesh</h3>
<p>从上面搜搜到的这段代码已经可以看出，<code class="highlighter-rouge">laodian-basic.js</code>这个文件是在<code class="highlighter-rouge">british.jsp</code>中被引用的，后者引入了大量的CSS/JS/FAVICON等文件，似乎是一个入口文件，但它却没有再被其他文件引用：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"laodian/common/js/laodian-libraries.generated.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"laodian/common/js/bootstrap.generated.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;home:script</span> <span class="na">bundle=</span><span class="s">"/bundles/laodian-basic.js"</span> <span class="na">useVersionNumber=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>

  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">href=</span><span class="s">"laodian/british/css/british-specific.less"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/head&gt;</span>

<span class="nt">&lt;body</span> <span class="na">id=</span><span class="s">"${activePage}"</span> <span class="na">class=</span><span class="s">"${activePage}"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;decorator:usePage</span> <span class="na">id=</span><span class="s">"specific-page"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"page"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;header</span> <span class="na">class=</span><span class="s">"Header"</span><span class="nt">&gt;</span>...<span class="nt">&lt;/header&gt;</span>
    <span class="nt">&lt;main</span> <span class="na">id=</span><span class="s">"main-wrapper"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;decorator:body</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/main&gt;</span>
    <span class="nt">&lt;footer</span> <span class="na">class=</span><span class="s">"Footer"</span><span class="nt">&gt;</span>...<span class="nt">&lt;/footer&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div>

<p>笔者眼尖，看到了<code class="highlighter-rouge">&lt;decorator&gt;</code>这个标签。它是SiteMesh框架定义的一个标签，sitemesh是一个分离页面内容和展现（presentation）的轻量级框架，其设计中运用了四人帮的装饰模式。Google Trends了一下它的热度，以及与它同类型的一些产品/框架的趋势，如下图，看起来似乎都要挂了。sitemesh3/tiles分别已经1/2年没维护了，只有wicket还在持续对Java8增加支持。这是不是意味着它所依附的模板技术也差不多日暮西山了？而模板技术又是前后端难以分离的一个重要的点，其实也从侧面印证了前后端分离的大趋势吧。</p>

<p><img src="http://7xqu8w.com1.z0.glb.clouddn.com/f366e36a7e197a73e0b3cb46c563658d.png" alt="Trends-jsp-freemarker-etc" /></p>

<p><img src="http://7xqu8w.com1.z0.glb.clouddn.com/0b4e597eb0f1fba6eefa6c0d774e0961.png" alt="Trends-sitemesh-tiles-etc" /></p>

<p>Anyway不要跑题，火速看一下sitemesh的<a href="http://wiki.sitemesh.org/wiki/display/sitemesh/Setup+SiteMesh+in+5+Minutes+or+Less">文档</a>，寻找启动项目的配置文件：<code class="highlighter-rouge">decorator.xml</code>！搜索一下项目的对应配置文件，果然有。看它的配置文件：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;decorators</span> <span class="na">defaultdir=</span><span class="s">"/WEB-INF/decorators"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;decorator</span> <span class="na">name=</span><span class="s">"master-decorator"</span> <span class="na">page=</span><span class="s">"main.jsp"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;pattern&gt;</span>/british<span class="nt">&lt;/pattern&gt;</span>
    <span class="nt">&lt;pattern&gt;</span>/america<span class="nt">&lt;/pattern&gt;</span>
    <span class="nt">&lt;pattern&gt;</span>/...<span class="nt">&lt;/pattern&gt;</span>
  <span class="nt">&lt;/decorator&gt;</span>
<span class="nt">&lt;/decorators&gt;</span>
</code></pre></div></div>

<p>这段代码在向我殷殷诉说：从特定路径下来的页面请求都会被<code class="highlighter-rouge">main.jsp</code>文件所前置装饰，再看到<code class="highlighter-rouge">main.jsp</code>文件：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">...</span>
<span class="o">&lt;%</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">target</span> <span class="o">=</span> <span class="n">getLocale</span><span class="o">();</span>
    <span class="n">request</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="s">"/WEB-INF/decorators/"</span> <span class="o">+</span> <span class="n">target</span> <span class="o">+</span> <span class="s">".jsp"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">include</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(...)</span> <span class="o">{</span>
<span class="o">%&gt;</span>
</code></pre></div></div>

<p>这段代码也验证了我们一开始的判断，即我们是通过类似<code class="highlighter-rouge">${locale}.jsp</code>的形式来引用目标jsp文件的。至此所有实现都已经很清楚了：<strong>通过SiteMesh对所有待渲染页面进行装饰，根据不同的地区分配到不同的<code class="highlighter-rouge">${locale}.jsp</code>模板去，后者再开始加载框架性（module模块化实现等）代码，最后渲染一般的html/js/jsp(template)。</strong></p>

<h2 id="总结与思考-further-thinking">总结与思考 Further Thinking</h2>

<p>许多时候一个项目的框架已经搭好，我们在使用的时候很少不会接触框架性的部分，比如js/css的压缩加载过程、多品牌的处理、框架选型等。既要写好业务代码，对于技术代码框架代码也要多了解，学会自己选型、搭脚手架。本文上篇讨论的其实是模块化的问题，下篇话题擦了模板技术的一点皮毛。深挖下去，还有许多问题可以了解：</p>

<ul>
  <li>模块化的现状与实现。包括吕立青在<a href="http://blog.jimmylv.info/2016-03-10-getting-webpack-done-and-js-module-history">这里</a>提到的一些相关技术或规范：CommonJS/AMD/WebPack/Browserify/NodeJS等</li>
  <li>模板技术。模板技术是依托于后端技术选型的，在选型的时候必须考虑现有的技术构架和迁移成本。另外在讨论模板技术孰优孰劣之前，也有必要先思考一下它所依托的后端框架的发展现状，比如Spring的生态圈（MVC/Boot)，比如是否必须要用Java来写后端代码等</li>
</ul>
