<p>在<a href="https://blog.linesh.tw/#/post/2018-10-18-javascript-prototypal-inheritance">上一篇文章</a>中，我们提到 ES6 的 <code class="highlighter-rouge">class</code> 语法糖是个近乎完美的方案，并且讲解了实现继承的许多内部机制，如 <code class="highlighter-rouge">prototype</code>/<code class="highlighter-rouge">__proto__</code>/<code class="highlighter-rouge">constructor</code> 等等。这篇，我们就以实际的 babel 代码为例子，来验证上节所言不虚。此外，本文还解释了 React 组件中你需要 <code class="highlighter-rouge">bind</code> 一下类方法的原理所在。</p>

<h2 id="目录">目录</h2>

<ul>
  <li>无继承——简单的 <code class="highlighter-rouge">class</code> + 字段声明</li>
  <li>无继承——简单的 <code class="highlighter-rouge">class</code> + 方法声明</li>
  <li>简单继承——一层继承 + 字段覆盖</li>
  <li>无继承——静态函数</li>
  <li>无继承——静态变量</li>
  <li>神秘的类 arrow function</li>
</ul>

<h2 id="无继承简单的-class--字段声明">无继承——简单的 <code class="highlighter-rouge">class</code> + 字段声明</h2>

<p>先来看个最简单的例子，我们仅仅使用了 <code class="highlighter-rouge">class</code> 关键字并定义了一个变量：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">Kat</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后 <a href="https://babeljs.io/repl/#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=Q&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=true&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Ces2017%2Creact%2Cstage-0%2Cstage-3&amp;prettier=false&amp;targets=&amp;version=6.26.0&amp;envVersion=">babel 编译出来</a>的代码如下。这里笔者用的是 Babel 6 的稳定版 6.26，不同版本编译出来可能有差异，但不至于有大的结构变动。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span>

<span class="kd">function</span> <span class="nx">_classCallCheck</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">Constructor</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">instance</span> <span class="k">instanceof</span> <span class="nx">Constructor</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="dl">'</span><span class="s1">Cannot call a class as a function</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">Animal</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">Animal</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">_classCallCheck</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">Animal</span><span class="p">)</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">Kat</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div>

<p>确实十分简单，对吧。这段代码值得留意的点有两个：</p>

<p>一个是，使用 <code class="highlighter-rouge">class</code> 声明的 <code class="highlighter-rouge">Animal</code> 最后其实是被编译为一个函数。证明 <code class="highlighter-rouge">class</code> 跟类没关系，只是个语法糖。</p>

<p>另一个地方是，编译器帮我们插入了一个 <code class="highlighter-rouge">_classCallCheck</code> 函数调用，它会检查你有没有用 <code class="highlighter-rouge">new Animal()</code> 操作符来初始化这个函数。若有，则 <code class="highlighter-rouge">this</code> 会是被实例化的 <code class="highlighter-rouge">Animal</code> 对象，自然能通过 <code class="highlighter-rouge">animal instanceof Animal</code> 检查；若是直接调用函数，<code class="highlighter-rouge">this</code> 会被初始化为全局对象，自然不会是 <code class="highlighter-rouge">Animal</code> 实例，从而抛出运行时错误。这个检查，正解决了<a href="https://blog.linesh.tw/#/post/2018-10-18-javascript-prototypal-inheritance">上一篇文章</a>提到的问题：如果忘记使用 <code class="highlighter-rouge">new</code> 去调用一个被设计构造函数的函数，没有任何运行时错误的毛病。</p>

<h2 id="无继承简单的-class--方法声明">无继承——简单的 <code class="highlighter-rouge">class</code> + 方法声明</h2>

<p>让我们再扩展一下例子，给它加两个方法。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">Kat</span><span class="dl">'</span>
  <span class="p">}</span>

  <span class="nx">move</span><span class="p">()</span> <span class="p">{}</span>
  <span class="nx">getName</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span>

<span class="kd">var</span> <span class="nx">_createClass</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">props</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nx">props</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span> <span class="o">=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span> <span class="o">||</span> <span class="kc">false</span>
      <span class="nx">descriptor</span><span class="p">.</span><span class="nx">configurable</span> <span class="o">=</span> <span class="kc">true</span>
      <span class="k">if</span> <span class="p">(</span><span class="dl">'</span><span class="s1">value</span><span class="dl">'</span> <span class="k">in</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">writable</span> <span class="o">=</span> <span class="kc">true</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">,</span> <span class="nx">protoProps</span><span class="p">,</span> <span class="nx">staticProps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">protoProps</span><span class="p">)</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">protoProps</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">staticProps</span><span class="p">)</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">,</span> <span class="nx">staticProps</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">Constructor</span>
  <span class="p">}</span>
<span class="p">})()</span>

<span class="kd">function</span> <span class="nx">_classCallCheck</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">Constructor</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">instance</span> <span class="k">instanceof</span> <span class="nx">Constructor</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="dl">'</span><span class="s1">Cannot call a class as a function</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">Animal</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">Animal</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">_classCallCheck</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">Animal</span><span class="p">)</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">Kat</span><span class="dl">'</span>
  <span class="p">}</span>

  <span class="nx">_createClass</span><span class="p">(</span><span class="nx">Animal</span><span class="p">,</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">move</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">value</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">move</span><span class="p">()</span> <span class="p">{},</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">getName</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">value</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">getName</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span>
      <span class="p">},</span>
    <span class="p">},</span>
  <span class="p">])</span>

  <span class="k">return</span> <span class="nx">Animal</span>
<span class="p">})()</span>
</code></pre></div></div>

<p>例子长了不少，但其实主要的变化只有两个：一是 <code class="highlighter-rouge">Animal</code> 被包了一层而不是直接返回；二是新增的方法 <code class="highlighter-rouge">move</code> 和 <code class="highlighter-rouge">getName</code> 是通过一个 <code class="highlighter-rouge">_createClass()</code> 方法来实现的。它将两个方法以 <code class="highlighter-rouge">key</code>/<code class="highlighter-rouge">value</code> 的形式作为数组传入，看起来，是要把它们设置到 <code class="highlighter-rouge">Animal</code> 的原型链上面，以便后续继承之用。</p>

<p>为啥 <code class="highlighter-rouge">Animal</code> 被包了一层呢，这是个好问题，但答案我们将留到后文揭晓。现在，我们先看一下这个长长的 <code class="highlighter-rouge">_createClass</code> 实现是什么：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">_createClass</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">props</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nx">props</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span> <span class="o">=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span> <span class="o">||</span> <span class="kc">false</span>
      <span class="nx">descriptor</span><span class="p">.</span><span class="nx">configurable</span> <span class="o">=</span> <span class="kc">true</span>
      <span class="k">if</span> <span class="p">(</span><span class="dl">'</span><span class="s1">value</span><span class="dl">'</span> <span class="k">in</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">writable</span> <span class="o">=</span> <span class="kc">true</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">,</span> <span class="nx">protoProps</span><span class="p">,</span> <span class="nx">staticProps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">protoProps</span><span class="p">)</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">protoProps</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">staticProps</span><span class="p">)</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">,</span> <span class="nx">staticProps</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">Constructor</span>
  <span class="p">}</span>
<span class="p">})()</span>
</code></pre></div></div>

<p>它是个立即执行函数，执行又返回了另一个函数。说明啥，一定用了闭包，说明里面要封装些「私有」变量，那就是 <code class="highlighter-rouge">defineProperties</code> 这个函数。这很好，一是这个函数只会生成一次，二是明确了这个函数只与 <code class="highlighter-rouge">_createClass</code> 这个事情相关。</p>

<p>再细看这个返回的函数，接受 <code class="highlighter-rouge">Constructor</code>、<code class="highlighter-rouge">protoProps</code> 和 <code class="highlighter-rouge">staticProps</code> 三个参数。<code class="highlighter-rouge">staticProps</code> 我们暂时不会用到，回头再讲；我们传入的数组是通过 <code class="highlighter-rouge">protoProps</code> 接受的。接下来，看一下 <code class="highlighter-rouge">defineProperties</code> 做了啥事。</p>

<p>它将每一个传进来的 props 做了如下处理：分别设置了他们的 <code class="highlighter-rouge">enumerable</code>、<code class="highlighter-rouge">configurable</code>、<code class="highlighter-rouge">writable</code> 属性。而传进来的 <code class="highlighter-rouge">target</code> 是 <code class="highlighter-rouge">Animal.prototype</code>，相当于，这个函数最后的执行效果会是这样：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">props</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 前面处理其实得到这样这个 descriptor 对象：</span>
    <span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">...</span><span class="nx">props</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span>
      <span class="na">enumerable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>看到这里就很明白了，它就是把你定义的 <code class="highlighter-rouge">move</code>、<code class="highlighter-rouge">getName</code> 方法通过 <code class="highlighter-rouge">Object.defineProperty</code> 方法设置到 <code class="highlighter-rouge">Animal.prototype</code> 上去。<a href="https://blog.linesh.tw/#/post/2018-10-18-javascript-prototypal-inheritance">前面</a>我们说过，<code class="highlighter-rouge">prototype</code> 是用来存储公共属性的。也就是说，这两个方法在你使用继承的时候，可以被子对象通过原型链上溯访问到。也就是说，我们这个小小的例子里，声明的两个方法已经具备了继承能力了。</p>

<p>至于 <code class="highlighter-rouge">enumerable</code>、<code class="highlighter-rouge">configurable</code>、<code class="highlighter-rouge">writable</code> 属性是什么东西呢，查一下<a href="https://www.ecma-international.org/ecma-262/6.0/#sec-property-attributes">语言规范</a>就知道了。简单来说，<code class="highlighter-rouge">writable</code> 为 <code class="highlighter-rouge">false</code> 时，其值不能通过 <code class="highlighter-rouge">setter</code> 改变；<code class="highlighter-rouge">enumerable</code> 为 <code class="highlighter-rouge">false</code> 时，不能出现在 <code class="highlighter-rouge">for-in</code> 循环中。当然，这里是粗浅的理解，暂时不是这篇文章的重点。</p>

<h2 id="简单继承一层继承--字段覆盖">简单继承——一层继承 + 字段覆盖</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">Kat</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Tiger</span> <span class="kd">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="nx">type</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">Paper</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>加一层继承和字段覆盖能看到啥东西呢？能看到继承底下的实现机制是怎么样的，以及它的 <code class="highlighter-rouge">constructor</code> 和 <code class="highlighter-rouge">__proto__</code> 属性将如何被正确设置。带着这两个问题，我们一起来看下编译后的源码：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span>

<span class="kd">function</span> <span class="nx">_possibleConstructorReturn</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nx">call</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">ReferenceError</span><span class="p">(</span>
      <span class="dl">"</span><span class="s2">this hasn't been initialised - super() hasn't been called</span><span class="dl">"</span>
    <span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">call</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">call</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">call</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">?</span> <span class="nx">call</span>
    <span class="p">:</span> <span class="nb">self</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">_inherits</span><span class="p">(</span><span class="nx">subClass</span><span class="p">,</span> <span class="nx">superClass</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">superClass</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">superClass</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span>
      <span class="dl">'</span><span class="s1">Super expression must either be null or a function, not </span><span class="dl">'</span> <span class="o">+</span>
        <span class="k">typeof</span> <span class="nx">superClass</span>
    <span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">subClass</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">superClass</span> <span class="o">&amp;&amp;</span> <span class="nx">superClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">constructor</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">value</span><span class="p">:</span> <span class="nx">subClass</span><span class="p">,</span>
      <span class="na">enumerable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">})</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">superClass</span><span class="p">)</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span>
      <span class="p">?</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">subClass</span><span class="p">,</span> <span class="nx">superClass</span><span class="p">)</span>
      <span class="p">:</span> <span class="p">(</span><span class="nx">subClass</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">superClass</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">_classCallCheck</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">Constructor</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">instance</span> <span class="k">instanceof</span> <span class="nx">Constructor</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="dl">'</span><span class="s1">Cannot call a class as a function</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">Animal</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">Animal</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">_classCallCheck</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">Animal</span><span class="p">)</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">Kat</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">Tiger</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">_Animal</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">_inherits</span><span class="p">(</span><span class="nx">Tiger</span><span class="p">,</span> <span class="nx">_Animal</span><span class="p">)</span>

  <span class="kd">function</span> <span class="nx">Tiger</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">_classCallCheck</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">Tiger</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_possibleConstructorReturn</span><span class="p">(</span>
      <span class="k">this</span><span class="p">,</span>
      <span class="p">(</span><span class="nx">Tiger</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">||</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">Tiger</span><span class="p">)).</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="nx">_this</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="nx">type</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">Paper</span><span class="dl">'</span>
    <span class="k">return</span> <span class="nx">_this</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">Tiger</span>
<span class="p">})(</span><span class="nx">Animal</span><span class="p">)</span>
</code></pre></div></div>

<p>相比无继承的代码，这里主要增加了几个函数。<code class="highlighter-rouge">_possibleConstructorReturn</code> 顾名思义，可能不是很重要，回头再读。精华在 <code class="highlighter-rouge">_inherits(Tiger, Animal)</code> 这个函数，我们按顺序来读一下。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">_inherits</span><span class="p">(</span><span class="nx">subClass</span><span class="p">,</span> <span class="nx">superClass</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">superClass</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">superClass</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span>
      <span class="dl">'</span><span class="s1">Super expression must either be null or a function, not </span><span class="dl">'</span> <span class="o">+</span>
        <span class="k">typeof</span> <span class="nx">superClass</span>
    <span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">subClass</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">superClass</span> <span class="o">&amp;&amp;</span> <span class="nx">superClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">constructor</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">value</span><span class="p">:</span> <span class="nx">subClass</span><span class="p">,</span>
      <span class="na">enumerable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">})</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">superClass</span><span class="p">)</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span>
      <span class="p">?</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">subClass</span><span class="p">,</span> <span class="nx">superClass</span><span class="p">)</span>
      <span class="p">:</span> <span class="p">(</span><span class="nx">subClass</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">superClass</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>首先是一段异常处理，简单地检查了 <code class="highlighter-rouge">superClass</code> 要么是个函数，要么得是个 null。也就是说，如果你这样写那是不行的：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Something</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">not-a-function</span><span class="dl">'</span>
<span class="kd">class</span> <span class="nx">Animal</span> <span class="kd">extends</span> <span class="nx">Something</span> <span class="p">{}</span>
<span class="c1">// Error: Super expression must either be null or a function, not string</span>
</code></pre></div></div>

<p>接下来这句代码将 <code class="highlighter-rouge">prototype</code> 和 <code class="highlighter-rouge">constructor</code> 一并设置到位，是精华。注意，这个地方留个问题：为什么要用 <code class="highlighter-rouge">Object.create(superClass.prototype)</code>，而不是直接这么写：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">_inherits</span><span class="p">(</span><span class="nx">subClass</span><span class="p">,</span> <span class="nx">superClass</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">subClass</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">superClass</span> <span class="o">&amp;&amp;</span> <span class="nx">superClass</span><span class="p">.</span><span class="nx">prototype</span>
  <span class="nx">subClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>很明显，是为了避免任何对 <code class="highlighter-rouge">subClass.prototype</code> 的修改影响到 <code class="highlighter-rouge">superClass.prototype</code>。使用 <code class="highlighter-rouge">Object.create(asPrototype)</code> 出来的对象，其实上是将 <code class="highlighter-rouge">subClass.prototype.__proto__ = superClass.prototype</code>，这样 <code class="highlighter-rouge">subClass</code> 也就继承了 <code class="highlighter-rouge">superClass</code>，可以达到这样两个目的：</p>

<ol>
  <li><code class="highlighter-rouge">superClass.prototype</code> 原型上发生的修改都能实时反映到 <code class="highlighter-rouge">subClass</code> 的实例上</li>
  <li><code class="highlighter-rouge">subClass.prototype</code> 上的任何修改不会影响到 <code class="highlighter-rouge">superClass.prototype</code></li>
</ol>

<p>最后，如果 <code class="highlighter-rouge">superClass</code> 不为空，那么将 <code class="highlighter-rouge">subClass.__proto__</code> 设置为 <code class="highlighter-rouge">superClass</code>。这是为了继承 <code class="highlighter-rouge">superClass</code> 的静态方法和属性。如以下的例子中，<code class="highlighter-rouge">Cat.TYPE</code> 能获取到 <code class="highlighter-rouge">Animal.TYPE</code>：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="nx">TYPE</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">PAPER</span><span class="dl">'</span>
  <span class="kd">static</span> <span class="nx">createTyping</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Animal</span><span class="p">.</span><span class="nx">TYPE</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Cat</span> <span class="kd">extends</span> <span class="nx">Animal</span> <span class="p">{}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Cat</span><span class="p">.</span><span class="nx">TYPE</span><span class="p">)</span>           <span class="c1">// PAPER</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Cat</span><span class="p">.</span><span class="nx">createTyping</span><span class="p">())</span> <span class="c1">// PAPER</span>
</code></pre></div></div>

<p>至此，一个简单的继承就完成了。在使用了 <code class="highlighter-rouge">extends</code> 关键字后，实际上背后发生的事情是：</p>

<ul>
  <li>子「类」<code class="highlighter-rouge">prototype</code> 上的 <code class="highlighter-rouge">__proto__</code> 被正确设置，指向父「类」的 <code class="highlighter-rouge">prototype</code>: <code class="highlighter-rouge">subClass.prototype = { __proto__: superClass.prototype }</code></li>
  <li>子「类」<code class="highlighter-rouge">prototype</code> 上的 <code class="highlighter-rouge">constructor</code> 被正确初始化，这样 <code class="highlighter-rouge">instanceof</code> 关系能得到正确结果</li>
  <li>子「类」的 <code class="highlighter-rouge">__proto__</code> 被指向父「类」，这样父「类」上的静态字段和方法能被子「类」继承</li>
</ul>

<p>好，要点看完了。后面内容跟继承关系不大，但既然源码扒都扒了，我们不妨继续深入探索一些场景：</p>

<h2 id="无继承静态函数">无继承——静态函数</h2>

<p>看一个简单的代码：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="nx">create</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Animal</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>首先要知道，这个「静态」同样不是强类型类继承语言里有的「静态」的概念。所谓静态，就是说它跟实例是没关系的，而跟「类」本身有关系。比如，你可以这样调用：<code class="highlighter-rouge">Animal.create()</code>，但不能这样用：<code class="highlighter-rouge">new Animal().create</code>。什么场景下会用到这种模式呢？比如说：</p>

<ul>
  <li>工厂模式或单例模式</li>
  <li><code class="highlighter-rouge">Object.create</code>、<code class="highlighter-rouge">Object.keys</code> 等常用方法</li>
</ul>

<p>既然只有通过构造函数本身去调用，而不能通过实例来调用，期望它们被绑定到函数本身上似乎很自然。我们来看看上面这段代码将被如何编译：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span>

<span class="kd">var</span> <span class="nx">_createClass</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">props</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nx">props</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span> <span class="o">=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span> <span class="o">||</span> <span class="kc">false</span>
      <span class="nx">descriptor</span><span class="p">.</span><span class="nx">configurable</span> <span class="o">=</span> <span class="kc">true</span>
      <span class="k">if</span> <span class="p">(</span><span class="dl">'</span><span class="s1">value</span><span class="dl">'</span> <span class="k">in</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">writable</span> <span class="o">=</span> <span class="kc">true</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">,</span> <span class="nx">protoProps</span><span class="p">,</span> <span class="nx">staticProps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">protoProps</span><span class="p">)</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">protoProps</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">staticProps</span><span class="p">)</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">,</span> <span class="nx">staticProps</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">Constructor</span>
  <span class="p">}</span>
<span class="p">})()</span>

<span class="kd">function</span> <span class="nx">_classCallCheck</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">Constructor</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">instance</span> <span class="k">instanceof</span> <span class="nx">Constructor</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="dl">'</span><span class="s1">Cannot call a class as a function</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">Animal</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">Animal</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">_classCallCheck</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">Animal</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">_createClass</span><span class="p">(</span><span class="nx">Animal</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">create</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">value</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">create</span><span class="p">()</span> <span class="p">{},</span>
    <span class="p">},</span>
  <span class="p">])</span>

  <span class="k">return</span> <span class="nx">Animal</span>
<span class="p">})()</span>
</code></pre></div></div>

<p>熟悉的函数，熟悉的配方。与本文的第二个例子相比，仅有一个地方的不同：<code class="highlighter-rouge">create</code> 方法是作为 <code class="highlighter-rouge">_createClass</code> 方法的第三个参数被传入的，这正是我们上文提到的 <code class="highlighter-rouge">staticProps</code> 参数：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">_createClass</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">,</span> <span class="nx">protoProps</span><span class="p">,</span> <span class="nx">staticProps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">protoProps</span><span class="p">)</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">protoProps</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">staticProps</span><span class="p">)</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">,</span> <span class="nx">staticProps</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">Constructor</span>
  <span class="p">}</span>
<span class="p">})()</span>

<span class="nx">_createClass</span><span class="p">(</span><span class="nx">Animal</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="p">[</span>
  <span class="p">{</span>
    <span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">create</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">value</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">create</span><span class="p">()</span> <span class="p">{},</span>
  <span class="p">},</span>
<span class="p">])</span>
</code></pre></div></div>

<p>可以看见，<code class="highlighter-rouge">create</code> 方法是直接被创建到 <code class="highlighter-rouge">Animal</code> 上的：<code class="highlighter-rouge">defineProperties(Animal, [{ key: 'create', value: function() {} }])</code>，最终会将函数赋给 <code class="highlighter-rouge">Animal.create</code>。我们的猜测并没有错误。</p>

<h2 id="无继承静态变量">无继承——静态变量</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Tiger</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="nx">TYPE</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">REAL</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div>

<p>还有个小例子。如果是静态变量的话，同样因为不希望在实例对象上所使用，我们会看到编译出来的代码中它是直接被设置到函数上。代码已经很熟悉，不必再讲。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span>

<span class="kd">function</span> <span class="nx">_classCallCheck</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">Constructor</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">instance</span> <span class="k">instanceof</span> <span class="nx">Constructor</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="dl">'</span><span class="s1">Cannot call a class as a function</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">Tiger</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">Tiger</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">_classCallCheck</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">Tiger</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">Tiger</span><span class="p">.</span><span class="nx">TYPE</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">REAL</span><span class="dl">'</span>
</code></pre></div></div>

<p>有趣的是，静态变量会不会被「子类」继承呢？这个可请读者自己做个实验，验证验证。</p>

<h2 id="神秘的类-arrow-function">神秘的类 arrow function</h2>

<p>写 React 的东西，一定遇见过这个问题：</p>

<p>```jsx harmony
class Button extends React.Component {
  constructor() {
    super()
    this.state = {
      isToggleOn: true,
    }
    // 画重点 👇👇👇👇👇👇👇👇👇👇👇👇
    // this.toggleButton = this.toggleButton.bind(this)
  }</p>

<p>static propTypes = {
    text: PropTypes.string,
  }</p>

<p>// ❌❌❌ Uncaught TypeError: this.setState is not a function
  toggleButton() {
    this.setState({
      isToggleOn: !this.state.isToggleOn,
    })
  }</p>

<p>render() {
    return &lt;button onClick={this.toggleButton}&gt;Toggle Me&lt;/button&gt;
  }
}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
为什么会有这个问题呢？因为你扔进去的 `this.toggleButton` 函数，在 `button` 内部一定是通过 `onClick()` 这样的方式来调用的，这样的话，`this` 引用就会丢失为 `undefined`，那么 `React.Component` 上的 `setState` 就调用不到。

可以直接去 React 官方示例看看：https://codepen.io/gaearon/pen/xEmzGg?editors=0010

```javascript
class Button extends React.Component {
  ...

  // ✅✅✅ This will work!
  toggleButton = () =&gt; {
    this.setState({ ... })
  }

  ...
}
</code></pre></div></div>

<p>解决方案呢，自然也有很多种，比如引用 <code class="highlighter-rouge">@autobind</code>、使用 ES7 的 <code class="highlighter-rouge">::this.toggleButton</code>、使用箭头函数等。比如上面 👆 这种最常用的解决方案。那么同学们有没有想过这个问题，为什么这样写 <code class="highlighter-rouge">this</code> 应用就可以正确拿到呢？「因为箭头函数将 <code class="highlighter-rouge">this</code> 绑定到词法作用域的上下文中了呀~」那谁来给我解释一下这句话呢？反正我是从来没理解过这个「外层」的作用域，应该是绑定到哪里。因此，只好另辟路径，直接看源码来理解这个写法的含义。</p>

<p>我写了个简单的例子，足以复现这个问题：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Button</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">}</span>

  <span class="nx">increment</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="mi">2</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">onClick</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">increment</span>
    <span class="nx">onClick</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当我们调用 <code class="highlighter-rouge">render()</code> 时，<code class="highlighter-rouge">increment()</code> 这样的调用方式会使 <code class="highlighter-rouge">this</code> 引用无法被初始化，这也正是我们传入的 <code class="highlighter-rouge">onClick</code> 在 React 中会被调用的方式。而上图的 <code class="highlighter-rouge">increment</code> 写法可以重新拯救失去的 <code class="highlighter-rouge">this</code> 引用！让我们来看看源代码，一探究竟。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span>

<span class="kd">var</span> <span class="nx">_createClass</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{})()</span>
<span class="kd">function</span> <span class="nx">_classCallCheck</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">Constructor</span><span class="p">)</span> <span class="p">{}</span>

<span class="kd">var</span> <span class="nx">Button</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">Button</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span>

    <span class="nx">_classCallCheck</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">Button</span><span class="p">)</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">increment</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">_this</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="p">}</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">}</span>

  <span class="nx">_createClass</span><span class="p">(</span><span class="nx">Button</span><span class="p">,</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">render</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">value</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">increment</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">increment</span>
        <span class="nx">increment</span><span class="p">()</span>
      <span class="p">},</span>
    <span class="p">},</span>
  <span class="p">])</span>

  <span class="k">return</span> <span class="nx">Button</span>
<span class="p">})()</span>
</code></pre></div></div>

<p>我略去了大家耳熟能详的代码，只留下关键的部分。可以看到，编译后的代码中，<strong>对 <code class="highlighter-rouge">Button</code> 实例的 <code class="highlighter-rouge">this</code> 引用被闭包保存了下来</strong>！这种写法，与以前我们 <code class="highlighter-rouge">var that = this</code> 的写法是一致的，我也终于理解「不再需要 that 引用了」以及各种语焉不详的作用域啊最外层变量啊这些理论。其实，就是 <code class="highlighter-rouge">this</code> 引用会始终被绑定到构造函数上，而这底下是通过闭包实现的。只是把你以前手写的代码自动化生成而已。</p>

<p>在本文的第二个例子中，我们留意到 <code class="highlighter-rouge">Animal()</code> 构造函数被额外包了一层，当时不得其解。看到这里，我们也许可以理解它的意图：就是为了将你在类中编写的箭头函数做个闭包，将 <code class="highlighter-rouge">this</code> 引用存储下来，以做后用。</p>

